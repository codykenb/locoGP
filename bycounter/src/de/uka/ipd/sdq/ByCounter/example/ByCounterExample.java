package de.uka.ipd.sdq.ByCounter.example;

import java.io.File;
import java.util.SortedSet;

import de.uka.ipd.sdq.ByCounter.execution.BytecodeCounter;
import de.uka.ipd.sdq.ByCounter.execution.CountingResultBase;
import de.uka.ipd.sdq.ByCounter.execution.CountingResultCollector;
import de.uka.ipd.sdq.ByCounter.results.CountingResult;
import de.uka.ipd.sdq.ByCounter.utils.MethodDescriptor;

/**
 * <p>
 * This example class demonstrates the usage of ByCounter in different 
 * scenarios. This includes usage of the options, description of the 
 * methods to instrument and aggregation of results. 
 * This class should be studied as source code.
 * </p>
 * <p>
 * See the ByCounter documentation for a more thorough exploration
 * of these examples.
 * </p>
 * 
 * @author Martin Krogmann
 * @author Michael Kuperberg
 * @since 0.1
 * @version 0.9
 */
public class ByCounterExample {
	
	/**
	 * This dummy method is here to get instrumented in the example.
	 * @param str Some {@link String} that gets printed.
	 * @param f Some float that contributes to the result.
	 * @return An int value that is computed based on input (cf. source code).
	 */
	public static int dummyMethodToBeInstrumented(String str, float f) {
		System.out.println(str);
		if(f > 0) {
			return -1;
		}
		int result = (int)(2*f);
		return result;
	}
	
	/**
	 * Quickstart example of the most basic ByCounter usage.
	 */
	@SuppressWarnings("boxing")
	public static void example1() {		
		//1. Set up a BytecodeCounter instance to use ByCounter, using a parameterless constructor. 
		BytecodeCounter counter = new BytecodeCounter();

		//2. Specify the method to be instrumented (several methods are supported as well)
		String className = "de.uka.ipd.sdq.ByCounter.example.ByCounterExample"; //$NON-NLS-1$
		MethodDescriptor myMethod = new MethodDescriptor(
				className,
				"public static int dummyMethodToBeInstrumented(java.lang.String str, float f)"); //$NON-NLS-1$
		
		//3. now tell ByCounter to instrument the specified method
		counter.addEntityToInstrument(myMethod);
		counter.instrument();

		//4. If the class which contains the method that we want to execute 
		// has no default constructor and the method is non-static, we need to 
		// provide construction parameters.
		// If a default constructor is available or the method you want to 
		// execute is static, you can skip this step.
		MethodDescriptor constructor = new MethodDescriptor(
				ByCounterExample.class.getCanonicalName(), 
				"public ByCounterExample(int number)");
		counter.setConstructionParameters(constructor, new Object[]{8});
		
		//5. let ByCounter execute the method (note that here, this class is reloaded internally)
		counter.execute(myMethod, new Object[] {"Hello world!", 0.0f});
		
		//6. now that ByCounter has completed counting, we can fetch the results,
		//i.e. get the result list from CountingResultCollector
		//"nonRecursively" means that even if the instrumented methods called 
		//other instrumented methods, the CountingResults of the callees are 
		//not inlined into those of callers
		SortedSet<CountingResult> results = 
			CountingResultCollector.getInstance().retrieveAllCountingResults().getCountingResults();
		
		//7. output the results to the console/log
		for(CountingResultBase r : results) {
			r.logResult(false, true);
		}
		
		//8. clear the results as we do not need them anymore
		CountingResultCollector.getInstance().clearResults();
	}
	
	/**
	 * Example of ByCounter usage with options.
	 * Watch the console output to see where the result log file is written.
	 */
	public static void example2() {
		//1. Set up a BytecodeCounter instance to use ByCounter. 
		BytecodeCounter counter = new BytecodeCounter();
		
		//2. In this example, we do not want to use the CountingResultCollector, so
		// we tell ByCounter to write to a log file instead.
		counter.getInstrumentationParams().setUseResultCollector(false);
		counter.getInstrumentationParams().enableResultLogWriter(
				"myResults" + File.separatorChar + "ByCounter_result_");
		
		//3. we want to keep the class files that are generated by ByCounter 
		// (to see what the instrumented file looks like), so we write the classes to disk
		counter.getInstrumentationParams().setWriteClassesToDisk(true);

		//4 If the class which contains the method that we want to execute 
		// has no default constructor, we need to provide construction parameters.
		// If a default constructor is available or the method you want to 
		// execute is static, you can skip this step.
		MethodDescriptor constructor = new MethodDescriptor(
				ByCounterExample.class.getCanonicalName(), 
				"public ByCounterExample(int number)");
		counter.setConstructionParameters(constructor, new Object[]{8});
		
		//5. we want to know more about the usage of arrays in our code
		counter.getInstrumentationParams().setUseArrayParameterRecording(true);

		//6. as in the first example, we specify the method to instrument
		MethodDescriptor myMethod = new MethodDescriptor(
				"de.uka.ipd.sdq.ByCounter.example.ByCounterExample",
				"public static int dummyMethodToBeInstrumented(java.lang.String str, float f)");
		
		//7. ... we tell ByCounter to instrument the specified method
		counter.addEntityToInstrument(myMethod);
		counter.instrument();
		
		//8. ... make ByCounter execute the method (note that this class must be reloaded! TODO check)
		counter.execute(myMethod, new Object[] {"Hello world!", 0.0f});
		
		//since we wrote the results to a log file, we are done with this example
	}

	/**
	 * The application entry point.
	 * @param args No arguments are needed or evaluated.
	 */
	public static void main(String[] args) {
		example1();
		System.out.println("\n\n\n\n\n");
		example2();
	}
	
	/**
	 * Examplary constructor with one argument.
	 * @param number An unimportant number. See explanations for
	 * {@link #example1()} of how non-"standard" constructors must be 
	 * treated in instrumentation, which is mandatory when no 
	 * default constructor is available because a parameterless default
	 * constructor is NOT declared while a non-default one (with params) is.
	 */
	public ByCounterExample(int number) {
		// we have nothing to do
		// this is for demonstration purposes only
	}

}
// TODO: consider the following
//TODO setConstructionParameters should return a runtime instance of the (instrumented) class, 
//allowing simpler invocations than using counter.execute(...) and less-invasive approach 
//(note that setConstructionParameter then needs to include a call to defineClass, 
//and thus should be renamed appropriately)

//TODO when creating several instances, possible using different constructors of the same class type 
//(which, then, must differ by parameters), the selection of constructor should be optional:
// a) constructInstrumentedInstance(String className /*default constructor*/) {throws UninstrumentedException, NoSuchConstructorException}
// b) constructInstrumentedInstance(String constructorSignature, Object[] constructorParameters) {throws UninstrumentedException, NoSuchConstructorException}

